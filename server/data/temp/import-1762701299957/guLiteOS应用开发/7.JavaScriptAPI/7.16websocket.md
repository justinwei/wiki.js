#### 一、模块介绍  
实现一个websocket的连接

#### 二、方法
##### 1、connect(url, [protocols], [extra_header])  
创建一个websocket连接, 返回一个对象
* url：需要连接的url  
* protocols ：子协议，可以是字符串或字符串数组，没有可不传
* extra_header：拓展头部，可选参数。使用该参数时，protocols必须填，没有可填空字符串
* 示例
```
var ws = require('websocket');
var wsClient = ws.connect("ws://localhost:3000/");
//var wsClient = ws.connect("ws://localhost:3000/", '', extra_header);
```  

##### 2、send(data)
向服务器发送数据
* data：可以是字符串或者buffer
* 示例：
```
wsClient.send("hello ws.");
```

##### 3、close([code], [reason])
关闭连接
* code：错误码，可选项
* reason：断开连接的原因，可选项， 长度不能超过123个字节
* 示例：
```
wsClient.close();
```

#### 三、属性
##### 1、readyState  
连接状态 
```
//0:CONNECTIING, 1:CONNECTED, 2:CLOSING, 3:CLOSED  
var state = wsClient.readyState
```

#### 四、事件
##### 1、open
当前连接已经建立好，可以发送和接收数据时触发
示例：
```
wsClient.on('open', function (option) {
    console.log('ws open, wsClient.readyState = ', wsClient.readyState)
});
```

##### 2、close
连接断开时触发
示例：
```
wsClient.on('close', function(option){
    console.log('ws close, wsClient.readyState = ', wsClient.readyState);
});
```

##### 3、error
通信过程中发生错误时触发, 返回错误信息
示例：
```
wsClient.on('error', function(option){
    console.log('ws error,  ', option);
});
```
```
//option  
typedef enum {
    	WS_CONNECTING,
    	WS_CONNECTED,
    	WS_DISCONNECTING,
        WS_DISCONNECT,
    	WS_CONN_ERR,         //连接错误
        WS_SEND_DATA_ERR,    //发送数据失败
        WS_RECV_DATA_ERR     //接收数据失败
} unit_ws_conn_state_t;
```

##### 4、message
接收到服务器发送的消息时触发，返回一个对象，成员如下示例中的结构体成员
示例：
```
typedef struct {
    char *payload;
    int payload_len;
    unsigned char is_final;     //是否最后一帧数据
    unsigned char is_fragment;  //数据是否是片段
} unit_ws_msg_t;

wsClient.on('message', function(msg){
    console.log('ws message,  ', msg.payload);
});
```

#### 五、例子
```
var ws = require('websocket');

var wsClient = ws.connect("ws://192.168.1.128:30200/");
var timer;
var cnt = 0;

function onconnect()
{
    console.log("send");
    wsClient.send("hello ws.");
}

wsClient.on('open', function (option) {
    console.log('ws open, wsClient.readyState = ', wsClient.readyState);
    timer = setInterval(onconnect, 500);
});

wsClient.on('error', function(error_info){
    console.log('ws error: ', error_info)
});

wsClient.on('message', function(msg){
    console.log('ws message, wsClient.readyState = ', wsClient.readyState);
    console.log('msg:', msg.payload);
    cnt++;
    console.log('cnt = ', cnt);
    if (cnt > 10) {
        cnt = 0;
        console.log('close');
        clearInterval(timer);
        wsClient.close();
    }
});

wsClient.on('close', function(option){
    console.log('ws close, wsClient.readyState = ', wsClient.readyState);
});
```

#### 六、补充
##### 1、证书存放在一个合并文件里，所有服务器通过域名解析
 证书打包示例：  
* 域名：localhost
* 命名：
certificate：localhost_cert
private_key：localhost_key
chain_certificate：localhost_chain
ca_certificate：localhost_ca
每个服务器所需证书根据实际情况加入，不需要四个都加。将所需文件打包成一个合并文件，并且在引擎中通过make menuconfig→mbedtls support→mbedtls support→certificate path配置该合并文件的存放