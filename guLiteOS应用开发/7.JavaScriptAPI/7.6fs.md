### 一、模块介绍
创建一个fs模块，实现文件的读写操作
### 二、异步API
#### 1、fs.open(path, flags, [mode], callback)  
打开文件，返回文件描述符，可通过文件描述符使用fs.close、fs.fsync、fs.read、fs.write操作文件
* path: 文件路径
* flags：文件打开行为，具体值见下文。
* mode：可选参数，设置文件权限，默认值为0666，rtos暂不支持
* callback：回调函数，带有两个参数如：callback(err, fd), fd为文件操作句柄
flags参数可以是以下值：

| flag | 描述 |
|:---- | :----|
|r|以读取模式打开文件。如果文件不存在抛出异常|
|r+|以读写模式打开文件。如果文件不存在抛出异常|
|w|以写入模式打开文件，如果文件不存在则创建|
|wx|类似 'w'，但是如果文件路径存在，则文件写入失败|
|w+|以读写模式打开文件，如果文件不存在则创建|
|wx+|类似 'w+'， 但是如果文件路径存在，则文件读写失败|
|a|以追加模式打开文件，如果文件不存在则创建|
|ax|类似 'a'， 但是如果文件路径存在，则文件追加失败|
|a+|以读取追加模式打开文件，如果文件不存在则创建|
|ax+|类似 'a+'， 但是如果文件路径存在，则文件读取追加失败|

#### 2、fs.close(fd, callback)
关闭文件
* fd：通过 fs.open() 方法返回的文件描述符
* callback：回调参数，没有参数
  
#### 3、fs.fsync(fd, callback)
同步文件
* fd：通过 fs.open() 方法返回的文件描述符
* callback：回调参数，没有参数

#### 4、fs.read(fd, [options], callback)
读取文件
* fd：通过 fs.open() 方法返回的文件描述符
* options：对象，包含以下属性
    * buffer-数据写入的缓冲区
    * offset-数据写入缓冲区的偏移量
    * length-要从文件中读取的字节数
    * position - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取，默认为null
* callback：有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象
  
#### 5、fs.write
写入文件
##### 1) 使用缓冲区 fs.write(fd, buffer, [options], callback)
* fd: 文件描述符
* buffer：要写入的缓冲区
* options：对象，包含以下属性
    * offset-确定要写入文件的缓冲区的偏移量
    * length-要写入文件的字节数
    * position-文件写入的起始位置，如果 position 的值为 null，则会从当前文件指针的位置写入，默认为null
* callback：回调函数，该函数接收错误和写入文件的字节数

##### 2) 使用字符串 fs.write(fd, string, [position], [encoding], callback)
* fd: 文件描述符
* string：要写入文件的字符串
* position: 文件写入的起始位置，如果 position 的值为 null，则会从当前文件指针的位置写入, 可选参数，默认为null
* encoding: 编码类型，默认为utf-8，可选参数
* callback：回调函数，该函数接收错误和写入文件的字节数
  
#### 6、fs.stat(path, callback)
获取文件信息
* path: 文件路径
* callback: 回调函数，带有两个参数(err, stats)，stats是一个对象或null，后面介绍

#### 7、fs.unlink(path, callback)
删除文件
* path：文件路径
* callback：回调函数，没有参数返回

#### 8、fs.rmdir(path, [option], callback)
删除目录
* path：文件路径
* option：对象，用于指定删除操作的可选参数，有三个可选参数
  * recursive：bool值，是否递归删除目录，默认为false
  * maxRetries：整数值，删除失败时最大重试次数，recursive为true时有效，默认为0
  * retryDelay：整数值，重试的等待时间，recursive为true时有效，默认为100
* callback：回调函数，返回err

#### 9、fs.mkdir(path, [option], callback)
创建目录
* path：文件路径
* option：对象，用于指定删除操作的可选参数，有三个可选参数
  * recursive：bool值，是否递归删除目录，默认为false
  * mode：文件夹权限，默认为0x0777, 目前不支持该参数
* callback：回调函数，返回err

#### 10、fs.opendir(path，[option], callback)
打开目录
* path：文件路径
* option：对象，影响输出的参数，有两个可选参数
  * encoding：字符串，默认为"utf8"
  * bufferSize:整型，指定读取目录时在内部缓冲的目录条目的数量，默认为32
* callback：回调函数
  * err：错误码
  * dir: fs.Dir对象
  
#### 11、fs.readdir(path, [option], callback)
读取目录信息
* path：文件路径
* option：对象，影响输出的参数，有两个可选参数
  * encoding：字符串，指定给回调参数指定的文件名使用哪种编码，默认为"utf8"
  * withFileTypes：bool值，指定是否将文件作为fs.Dirent对象返回，默认值为"false"
* callback：回调函数
  * err：错误码
  * files: 目录中文件的String，Buffer或fs.Dirent对象的数组

#### 12、fs.readFile(path, [option], callback)
读取文件
* path：文件路径
* option：对象，影响输出的参数，有两个可选参数
  * encoding：字符串，指定编码格式，默认为null
  * flag：操作文件的标志，默认为"r"
* callback：回调函数
  * err：错误码
  * data: 读取的文件数据
  
#### 13、fs.writeFile(path, data, [option], callback)
写入文件
* path：文件路径
* data：要写入数据的缓冲区，可以是buffer、string
* option：对象，影响输出的参数，有两个可选参数
  * encoding：字符串，指定编码格式，默认为"utf8"
  * mode：文件权限，默认值：0x0666，暂不支持
  * flag：操作文件的标志，默认为"w"
* callback：回调函数
  * err：错误码

#### 14、fs.appendFile(path, [option], callback)
追加写文件
* path：文件路径
* data：要写入数据的缓冲区，可以是buffer、string
* option：对象，影响输出的参数，有两个可选参数
  * encoding：字符串，指定编码格式，默认为"utf8"
  * mode：文件权限，默认值：0x0666，暂不支持
  * flag：操作文件的标志，默认为"a"
* callback：回调函数
  * err：错误码

#### 15、fs.copyFile(src, dest，[mode], callback)
复制文件
* src：要复制的源文件路径
* dest：赋值操作的目标路径
* mode：整型，用于赋值操作的修饰符，默认为0。 暂不支持
* callback：回调函数
  * err：错误码

#### 16、fs.rename(oldPath, newPath, callback)
文件重命名，如果newpath已经存在，则覆盖，如果oldPath与newPath文件类型不一致，则报错
* oldPath：源文件路径
* newPath：新文件路径
* callback：回调函数
  * err：错误码

#### 17、fs.rm(path, [option], callback)
删除文件
* path：文件路径
* option：对象，影响输出的参数，有两个可选参数
  * force：bool值，当为ture时，如果path不存在，则异常将被忽略
  * recursive：bool值，是否递归删除目录，默认为false
  * maxRetries：整数值，删除失败时最大重试次数，recursive为true时有效，默认为0
  * retryDelay：整数值，重试的等待时间，recursive为true时有效，默认为100
* callback：回调函数
  * err：错误码

#### 18、fs.readSortDir(path, [option], callback)
对当前路径下的文件进行排序，该接口只有异步接口，不开放同步接口
* path： 文件路径
* option： 对象，影响输出的参数，
    * updateCache：整数值，数值1代表清空全局链表，并且重新生成更新该目录对应的索引文件，目的主要是为了t卡热插拔后，清除缓存，重新进行索引文件的更新。数值2代表用户改变当前目录的排序方式。其余情况传入数字0
    * encoding：字符串，指定编码格式，默认为"utf8"
    * withFileTypes：bool值，指定是否将文件作为fs.Dirent对象返回，若要获取完整排序信息，该值需要传入true
    * sortType：整数值，代表排序方式，1表示按文件名升序排序，2表示按文件名降序排序，3表示按照大小升序排序，4表示按照大小降序排序,默认传入1
    * startIndex:  整数值，代表要返回文件的起始位置，默认为0
    * endIndex:  整数值，指定要返回文件的终止位置，不可以传0进来
    * filterExt：字符串， 只返回该后缀名的文件，支持返回一种或者多种，例如：".mp3,.wav,.aac"，如果不需要过滤，不需要传进这个值
    * fileType：整数值，数值0代表需要文件夹+文件，数值1代表只需要文件，数值2代表只需要文件夹
* callback：回调函数
    err: 错误码
    data: 目录中文件的String，Buffer或fs.Dirent对象的数组
    data数据的格式例子：
    ```javascript
    {
      "int_1":0,
      "obj_1":{
          "totalCount":6, // 目标目录下文件+文件夹总个数
          "fileCount":4,// 目标目录下文件夹的总数
          "folderCount":2// 目标目录下文件夹的总数
          "fileList":[
            {"name":"1.txt","type":1,"size":0},
            {"name":"2.txt","type":1,"size":0},
            {"name":"3.txt","type":1,"size":0},
            {"name":"MP3","type":2,"size":0},
            {"name":"a.c","type":1,"size":0},
            {"name":"callback.c","type":1,"size":0},
          ]
      }
    }
    ```
### 三、同步API 
以下方法的参数含义查看异步api解释
#### 1、fs.openSync(path, flags, [mode])  
打开文件
* 返回值：fd 文件描述符

#### 2、fs.closeSync(fd)
关闭文件
* 返回值：err 错误码
  
#### 3、fs.fsyncSync(fd)
同步文件
* 无返回值

#### 4、fs.readSync(fd, [options])
读取文件
* 返回值：byteRead 实际读取的字节大小
  
#### 5、fs.writeSync
写入文件
##### 1) 使用缓冲区 fs.writeSync(fd, buffer, [options])
* 返回值：wbyte 实际写入的字节大小
##### 2) 使用字符串 fs.writeSync(fd, string, [position], [encoding])
* 返回值：wbyte 实际写入的字节大小
  
#### 6、fs.statSync(path)
获取文件信息
* 返回值：fs.stats对象或null

#### 7、fs.unlinkSync(path)
删除文件
* 无返回值

#### 8、fs.rmdirSync(path, [option])
删除目录
* 无返回值

#### 9、fs.mkdirSync(path, [option])
删除目录
* 无返回值

#### 10、fs.opendirSync(path，[option])
打开目录
* 返回值：fs.Dir对象或null
  
#### 11、fs.readdirSync(path, [option])
删除目录
* 返回值：字符串或者fs.Dirent对象

#### 12、fs.readFileSync(path, [option])
读取文件
* 返回值：读取的文件数据
  
#### 13、fs.writeFileSync(path, data, [option])
写入文件
* 返回值：err 错误码

#### 12、fs.appendFileSync(path, [option])
追加写文件
* 返回值：err 错误码

#### 13、fs.copyFileSync(src, dest，[mode])
复制文件
* 返回值：err 错误码

#### 14、fs.renameSync(oldPath, newPath)
文件重命名，如果newpath已经存在，则覆盖，如果oldPath与newPath文件类型不一致，则报错
* 返回值：err 错误码

#### 15、fs.rmSync(path, [option])
删除文件和目录
* 返回值：err 错误码

### 四、fs的类对象
#### 1、stats对象
| 属性（方法） | 描述 |
|:---- | :----|
|stats.size|返回文件大小|
|stats.isFile()|如果是文件返回 true，否则返回 false|
|stats.isDirectory()|如果是目录返回 true，否则返回 false|

#### 2、Dir对象
使用该对象的方法时，不要同步异步混合使用
| 属性（方法） | 参数 | 描述 |
|:---- | :----| :----|
|Dir.path|无|此目录的只读路径|
|Dir.close(callback)|callback：回调函数(返回err)|异步地关闭目录的底层资源句柄|
|Dir.closeSync()|err:函数返回值|同步地关闭目录的底层资源句柄|
|Dir.read(callback)|callback：回调函数(返回err，dirent)|异步地读取下一个目录条目|
|Dir.readSync()|dirent：函数返回值，返回一个目录信息|同步地读取下一个目录条目|

#### 3、Dirent对象
| 属性（方法） | 描述 |
|:---- | :----|
|Dirent.name|文件名|
|Dirent.type|文件类型|
|Dirent.size|文件大小|
|Dirent.isFile()|如果是文件返回 true，否则返回 false|
|Dirent.isDirectory()|如果是目录返回 true，否则返回 false|

### 五、例子
       var fs = require('fs');

    //异步打开、读取、关闭文件
    fs.open("fatfs/test/test.js", "r+", function event(err, fd) {
        console.log("err = ", err);
        console.log("open fd = ", fd);
        var buffer = new Buffer(101);
        var options = new Object();
        options.offset = 0;
        options.length = 100;
        options.position = 0;

        // //读文件
        fs.read(fd, buffer, options, function event(err, bytes,buffer) {
            console.log("err = ", err);
            console.log("bytes = ", bytes);

            if(bytes > 0){
                console.log(buffer.slice(0, bytes).toString());
            }
        });

        fs.close(fd, function event() {
            console.log("file is close.");
        });
    });

    //同步打开、读取、关闭文件
    var fd = fs.openSync("fatfs/test/mqtt.js", "r");
    console.log("openSync fd = ", fd);
    var buffer = new Buffer(257);
    var options = new Object();
    options.offset = 0;
    options.length = 256;
    options.position = 0;
    console.log("readSync bytes = ", fs.readSync(fd, buffer, options));
    console.log("buffer = ", buffer.toString());
    fs.closeSync(fd);

    //异步方式打开、写入、同步、关闭文件
    fs.open("fatfs/test_w.txt", "w", function event(err, fd) {
        console.log("err = ", err);
        console.log("fd = ", fd);
        buffer = new Buffer(101);
        buffer.write("1111111111") ;
        var options = new Object();
        options.offset = 0;
        options.length = buffer.length;
        options.position = 0;

        //写文件
        fs.write(fd, buffer, options, function event(err, bytes) {
            console.log("err = ", err);
            console.log("bytes = ", bytes);
        });
        fs.fsync(fd, function event() {
            console.log("fsync");
        });
        var str = "aaaaaaaaaaaaa";

        fs.write(fd, str, function event(err, bytes) {
            console.log("err = ", err);
            console.log("bytes = ", bytes);
        });

        fs.fsync(fd, function event() {
            console.log("fsync");
        });

        fs.close(fd, function event() {
            console.log("file is close.");
        })
    })

    //同步打开、写入、关闭文件
    var fd = fs.openSync("fatfs/testsync_w.txt", "w");
    console.log("openSync fd = ", fd);
    console.log("writeSync bytes = ", fs.writeSync(fd, "测试writeSync接口"));
    fs.closeSync(fd);

    //查看文件或文件夹信息
    fs.stat("fatfs/test", function(err, stats) {
        console.log("stat isdir = ", stats.isDirectory());
        console.log(stats.size);
    });
    var stats = fs.statSync("fatfs/test");
    console.log("statSync isdir = ", stats.isDirectory());

    //删除文件
    fs.unlink("fatfs/custom/unlink.txt", function(err) {
        console.log("unlink err = ", err);
    })
    fs.unlinkSync("fatfs/custom/unlinksync.txt");

    //删除空目录
    var option = {
        recursive: true,
        maxRetries: 1,
        retryDelay: 100
    };

    // 递归
    fs.rmdir("fatfs/rmdir/test1/test2", option, function(err) {
        console.log("rmdir err = ", err);
    })
    fs.rmdirSync("fatfs/rmdirSync/test1/test2", option);

    // 非递归
    fs.rmdir("fatfs/rmdir/test1/test2", function(err) {
        console.log("rmdir err = ", err);
    })
    fs.rmdirSync("fatfs/rmdirSync/test1/test2");

    //递归创建目录
    var mkdir_option = {
        recursive: true,
    };
    fs.mkdir("fatfs/mkdir/test2/test3/test4/test5", mkdir_option, function(err) {
        console.log("mkdir err = ", err);
    })
    fs.mkdirSync("fatfs/mkdirSync/test2/test3/test4/test5", mkdir_option);

    // 获取目录
    fs.opendir("fatfs/test", function(err, dir) {
        console.log("opendir fatfs/test");

        if (!err) {
            console.log("Path of the directory:", dir.path); 
            dir.read(function(err, dirent) {
                console.log("dirent1: ", dirent);
            });
            dir.read(function(err, dirent) {
                console.log("dirent2: ", dirent);
            });
            dir.close(function(err){
                console.log("close this dir");
            });

        }
    });

    // 异步
    var dir = fs.opendirSync("fatfs/tmp");
    console.log("opendirSync dirent1: ", dir.readSync());
    console.log("opendirSync dirent2: ", dir.readSync());
    console.log("opendirSync close ret: ", dir.closeSync());

    // 读取目录
    var options = {
        withFileTypes: true
    };

    // 同步
    fs.readdir("fatfs/test", options, function(err, dir) {
        if (err) 
            console.log(err); 
        else { 
            console.log("\nCurrent directory filenames:"); 
                dir.forEach(function(file) { 
                console.log(file); 
            }) 
        }
    })

    // 异步
    var dir = fs.readdirSync("fatfs/test", options);
    dir.forEach(function(file) { 
        console.log(file); 
    })

    //对当前目录下文件进行排序
    var options_sort = {
        updateCache: 1,
        withFileTypes: true,
        encoding: "utf8",
        sortType: 1,
        startIndex: 40,
        maxCount: 59,
        filterExt: ".mp3,.txt"
    };
    var path = "/fatfs/test
    fs.readSortDir(path, options_sort, function(err, dir) {
            if (err) 
                console.log(err); 
            else { 
                // 检查 dir 对象和其 data 属性是否存在
                if (dir && dir.data) {
                    const total_count = dir.data.total_count;
                    const dirent = dir.data.dirent;
                    //遍历 dirent 数组
                    dirent.forEach(function (file) {
                        console.error(JSON.stringify(file));
                });
            } else {
                    console.error('Invalid directory data format.');
                }
            }
            console.error("readdirsort執行時間 = ", device.getTimeMs() - time);
        })

    // 读取整个文件
    fs.readFile("fatfs/images|answer_results_bg.sjpg", function(err, data) {
        if (!err) {
            console.log(data.toString());
        }
    })
    console.log("file data = ", fs.readFileSync("fatfs/test/mqtt.js").toString());

    // 写文件
    fs.writeFile("fatfs/writefile.txt", "测试writeFile", function(err) {
        console.log("测试writeFile err:", err);
    })
    console.log("writeFlieSync err:  ", fs.writeFileSync("fatfs/writeFileSync.txt", "测试writeFileSync"));

    // 追加写文件
    fs.appendFile("fatfs/writefile.txt", "测试appendFile", function(err) {
        console.log("appendFile err:", err);
    })
    console.log("appendFileSync err:  ", fs.appendFileSync("fatfs/writeFileSync.txt", "测试appendFileSync"));

    // 复制文件
    fs.copyFile("fatfs/writefile.txt", "fatfs/copyFile.txt", function(err) {
        console.log("copyFile err:", err);
    })
    console.log("copyFileSync err:  ", fs.copyFileSync("fatfs/writeFileSync.txt", "fatfs/copyFileSync.txt"));

    // 重命名文件
    fs.rename("fatfs/copyFile.txt", "fatfs/test", function(err) {
        console.log("rename err:", err);
    })
    console.log("renameSync err:  ", fs.renameSync("fatfs/copyFileSync.txt", "fatfs/tmp"));

    // rm
    fs.rm("fatfs/copyFile.txt", function(err) {
        console.log("rm err:", err);
    })
    var opt = {
        recursive: true
    };
    console.log("rmSync err:  ", fs.rmSync("fatfs/mkdir", opt));