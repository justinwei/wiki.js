### 一、模块介绍
创建一个mqtt连接，实现客户端与服务端的通信
### 二、API
#### 1、mqtt.connect()
创建mqtt连接，返回一个mqttClient对象
URL 可以是以下协议：mqtt, mqtts        示例：Url = "mqtt://test.gurobot.cn:1883"
Options：
+ keepalive: 单位为秒，数值类型，默认为 60 秒，设置为 0 时禁止
+ clientId: 默认为 'mqttjs_' + Math.random().toString(16).substr(2, 8)，可以支持自定义修改的字符串 。可以是字符串或者buffer，如果是二进制数据，需使用buffer
+ version: MQTT 协议版本号，目前只支持3和4
+ clean: 默认为 true，是否清除会话。当设置为 true 时，断开连接后将清除会话，订阅过的 Topics 也将失效。当设置为 false 时，离线状态下也能收到 QoS 为 1 和 2 的消息
+ reconnectPeriod: 重连间隔时间，单位为毫秒，默认为 1000 毫秒，注意：当设置为 0 以后将取消自动重连
+ connectTimeout: 连接超时时长，收到 CONNACK 前的等待时间，单位为毫秒，默认 30000 毫秒
+ username: 认证用户名，如果 Broker 要求用户名认证的话，请设置该值。可以是字符串或者buffer，如果是二进制数据，需使用buffer
+ password: 认证密码，如果 Broker 要求密码认证的话，请设置该值。可以是字符串或者buffer，如果是二进制数据，需使用buffer
+ will: 遗嘱消息，一个可配置的对象值，当客户端非正常断开连接时，Broker 就会向遗嘱 Topic 里面发布一条消息，格式为：
    + topic: 遗嘱发送的 Topic    可以是字符串或者buffer，如果是二进制数据，需使用buffer
    + payload: 遗嘱发布的消息    可以是字符串或者buffer，如果是二进制数据，需使用buffer
    + qos: 遗嘱发送的 QoS 值
    + retain: 遗嘱发布的消息的 retain 标志
+ ca: 只有在服务器使用自签名证书时才有必要，自签名证书中生成的 CA 文件
+ ca_len: ca数据的长度  

#### 2、mqttClient.subscribe(topic,  option, function event(err, granted) { })
订阅一个或者多个 topic 的方法，当连接成功需要订阅主题来获取消息，该方法包含三个参数：
+ topic: 可传入一个字符串，或者一个字符串数组，也可以是一个 topic 对象，{'test1': {qos: 0}, 'test2': {qos: 1}}
+ options: 可选值，订阅 Topic 时的配置信息，主要是填写订阅的 Topic 的 QoS 等级的
+ callback: 订阅 Topic 后的回调函数，参数为 err 和 granted，granted 是一个 {topic, qos} 的数组，其中 topic 是一个被订阅的主题，qos 是 Topic 是被授予的 QoS 等级

#### 3、mqttClient.publish(topic, message, option, func (err){ })
向某一 topic 发布消息的函数方法，其中包含四个参数：
+ topic: 要发送的主题，为字符串
+ message: 要发送的主题的下的消息，可以是字符串或者是 Buffer
+ options: 可选值，发布消息时的配置信息，主要是设置发布消息时的 QoS、Retain 值等。
+ callback: 发布消息后的回调函数

#### 4、mqttClient.unsubscribe(topic, function event(ret){ })
取消订阅单个主题或多个主题，该方法包含三个参数：
+ topic: 可传入一个字符串或一个字符串数组
+ callback: 取消订阅时的回调函数，参数为 error，当取消订阅失败时 error 参数才存在

#### 5、mqttClient.end()
关闭客户端

### 三、事件
#### 1、connect
当连接成功时触发，参数为 connack
```
mqttClient.on("connect", function event(connack){ })
```

#### 2、reconnect
当断开连接后，经过重连间隔时间重新自动连接到 Broker 时触发
```
mqttClient.on("reconnect", function event( ){ })
```
#### 3、close
在断开连接以后触发
```
mqttClient.on("close", function event( ){ })
```

#### 4、offline
当客户端下线时触发
```
mqttClient.on("offline", function event( ){ })
```

#### 5、error
当客户端无法成功连接时或发生解析错误时触发，参数 error 为错误信息
```
mqttClient.on("error", function event( ){ })
```

#### 6、message
当客户端收到一个发布过来的 Payload 时触发，其中包含三个参数，topic、payload 和 packet，其中 topic 为接收到的消息的 topic，payload 为接收到的消息内容，packet 为 MQTT 报文信息，其中包含 QoS、retain 等信息  
```
mqttClient.on("message", function event(topic, payload, packet){ })
```

### 例子
```
var mqtt = require('mqtt');

const connectUrl = "mqtts://aumvlad.iot.gz.baidubce.com:1884"
var id = "aumvlad542372100000000b";
var user ="thingidp@aumvlad|542372100000000b|0|MD5";
var pass = "1a00563e5b89651dfe04987e5e0ec267";
var time_id1 = 0;
var time_id2 = 0;

var option = {
    clientId: id,
    keepalive: 60,
    clean: false,
    version: 4,
    reconnectPeriod: 1000,
    connectTimeout: 4000,
    ca: "",
    ca_len: 0,
    username: user,
    password: pass
}

function onConnect() {
    // subscribe
    var topic_obj = "story/542372100000000b/server"
    var sub_option = {
        qos: 0
    }
    mqttClient.subscribe(topic_obj, JSON.stringify(sub_option), function event(err, granted) {
        console.log("err = ", err);
        var cnt = granted.length
        // console.log("cnt ", cnt)
    });
    
    //publish
    var option = {
        cmd: "customer",
        head: {
          id: 4098,
          sn: 20322,
          cmd: "getConfigInfo",
          src: "542372100000000b",
          dst: "server"
        },
        body: {
          version: "",
          config: []
        }
      }
    
    function publish() {
        mqttClient.publish("story/542372100000000b/client", JSON.stringify(option), { qos: 0, retain: false }, function event(err) {
            console.log("err = ", err)
        })
    }

    time_id1 = setInterval(publish, 2 * 1000);
    // console.log("time_id1 = ", time_id1)
    // clearInterval(time_id);

    // time_id2 = setTimeout(publish, 2 * 1000);
    // console.log("time_id2 = ", time_id2)
    // clearTimeout(time_id2);

}

//create mqtt client
var mqttClient = mqtt.connect(connectUrl, option);

mqttClient.on('connect', function(connack) {
    console.log('mqtt connected ', connack);
    onConnect();
});

var i = 0;
mqttClient.on('message', function(topic, payload, packet) {
    console.log('topic = ', topic);
    console.log('message = ', payload);
    console.log('packet = ', packet);

    
    // i++;
    // if (i > 2) {
    //     i = 0;
    //     console.log("time_id = ", time_id1)
    //     clearInterval(time_id1);
        
    //     setTimeout(function () {
    //         mqttClient.end();
    //         console.log("app end.");
    //     }, 1 * 1000);

    //     function connect() {
    //         mqttClient = mqtt.connect(connectUrl, option);
    //     }
    //     time_id2 = setTimeout(connect, 5 * 1000);
    // }
});


```
