### 一、模块介绍
实现sqlite3接口，方便用户对数据库进行增删改查的操作
### 二、api
#### 1、new sqlite3.Database(filename,[mode],[callback])
返回数据库对象并且自动打开和连接数据库
* filename：数据库名称
* mode：可选， 数据库的模式，默认值为6 （OPEN_READWRITE |OPEN_CREATE）
    * OPEN_READONLY（只读）：1
    * OPEN_READWRITE（可读写）：2
    * OPEN_CREATE（可创建）：4
* callback：可选，回调函数, 返回err，当它为null，表示打开成功
  
#### 2、db.close([callback])
关闭一个数据库连接对象
* callback（可选）:关闭成功的回调。 第一个参数是一个错误对象，当它为“null”时，表示关闭成功

#### 3、db.run(sql, [param, ...], [callback])
该方法可以执行 DDL 和 DML 语句，如建表、删除表、删除行数据、插入行数据等，参数
* sql：要运行的 SQL 字符串。sql 的类型是 DDL 和 DML，DQL 不能使用这个命令。执行后返回值不包含任何结果，必须通过 callback 回调函数获取执行结果
* param,...（可选）：当 SQL 语句包含占位符（?）时，这里可以传对应的参数。 这里有两种传值方法，如：
  ```
  // 直接通过参数传值.
    db.run("UPDATE tbl SET name = ? WHERE id = ?;", "bar", 2);

    // 将值封装为一个数组传值.
    db.run("UPDATE tbl SET name = ? WHERE id = ?;", ["bar", 2]);

  ```
* callback（可选）：如果执行成功，则第一个参数为 null，否则就是出错

#### 4、db.exec(sql, [callback])
与run方法都是执行DDL和DML语句，可以执行多条语句，并且不支持占位符参数
* sql：要运行的 SQL 字符串
* callback（可选）：如果执行成功，则第一个参数为 null，否则就是出错

#### 5、db.get(sql, [param, ...], [callback])
获取第一条查询到的数据
* sql：要运行的 SQL 字符串, sql 的类型是 DQL
* param,...（可选）: 与run方法一致
* callback（可选）：function（err，row），如果执行成功，则第一个参数为 null，否则就是出错。如果查询结果集为空，则第二个参数为 undefined；否则第二个参数值是查询到的第一个对象，他是个 json 对象，属性名称对应于结果集的列名称，因此查询的每一列都应该给出一个列表名

#### 6、db.all(sql, [param, ...], [callback])
获取所有查询到的数据
* sql：要运行的 SQL 字符串
* param,...（可选）: 与run方法一致
* callback（可选）：function（err，rows），如果执行成功，则第一个参数为 null，否则就是出错。rows是一个数组

#### 7、db.each(sql, [param, ...], [callback], [complete])
与all方法一样，但是是每查到一行返回一次
* sql：要运行的 SQL 字符串
* param,...（可选）: 与run方法一致
* callback（可选）：function（err，row），如果执行成功，则第一个参数为 null，否则就是出错。如果结果集成功但为空，则不会调用回调。对于每个检索到的行，该方法都会调用一次回调。执行顺序与结果集中的行顺序完全对应
* complete（可选）：调用所有行回调后，如果存在 complete 回调函数，将调用这个回调。第一个参数是一个错误对象，第二个参数是检索行数

#### 7、db.prepare(sql, [param, ...], [callback])
执行后，会返回一个命令对象，这个命令对象可以反复执行。
* sql：要运行的 SQL 字符串
* param,...（可选）: 与run方法一致
* callback（可选）：如果执行成功，则第一个参数为 null，否则就是出错

以下是这个命令对象（statement ）的 api：
  * Statement.run([param, ...], [callback])
  * Statement.get([param, ...], [callback])
  * Statement.all([param, ...], [callback])
  * Statement.each([param, ...], [callback], [complete])  

以上 api 方法与 Database 的同名方法调用方式相同。不同点是这里的 Statement 对象是可以复用的，避免了重复编译 sql 语句，这些方法的 param 参数都会对 Statement 对象绑定参数，在下一次执行的时候，如果没有重新绑定参数，是会使用上一次参数的


### 三、例子

```
var sqlite3 = require('sqlite3');

var db = new sqlite3.Database("fatfs/sqlite3_db/mydatebase.db", function(err) {
  if (err) throw err;
});

db.run("CREATE TABLE if not exists stu(id INT, name TEXT, age INT);", function(e) {
   if (e !== null) {
     throw e;
   }
});

db.each("select * from stu;", function(err, row) {
     console.log(row);
})

db.get("select * from stu where age = 20;", function(err, row){
  console.log(row);
})

db.run("UPDATE stu SET name = ? WHERE age = ?;", ["lisi", 19]);

db.exec("DELETE FROM stu WHERE name = 'wangwu';");

db.all("select * from stu;", function(err, row){
   console.log(JSON.stringify(row));
})

var stat = db.prepare("INSERT INTO stu VALUES(?, ?, ?)");
stat.run(5, "lisi", 23);
stat.run(6, "wangwu", 27);

stat = db.prepare("select * from stu;");
stat.all(function(err, row) {
  console.log(row);
});

```