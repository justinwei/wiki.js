# http

## 一、模块介绍

​	创建一个http请求

## 二、API

#### 1、http.request(option, [cb])

发起http请求，返回一个对象

- option：请求参数的对象，包含url、method、timeout、header等
- cb：回调，请求成功时响应 返回一个对象，包含成员statusCode、headers
##### 注意 body包含在option中，回调返回的对象包含接收到的body（buffer），具体请查看下面的例子

#### 2、req.write(data, [encoding], [callback])

向前面发送的请求发送请求主体

- data：请求体，string或者buffer
- encoding: 可选参数，编码类型，默认utf-8
- callback: 回调，可选参数

#### 3、req.end([data], [encoding], [callback])

- data：可选参数，请求体，string或者buffer
- encoding: 可选参数，编码类型，默认utf-8
- callback: 回调，可选参数

#### 4、req.destroy()

终止当前http请求
#### 5、http.requestSync(options)
http同步请求，返回一个response对象
- options：请求参数的对象，包含url、method、timeout、header、body等

#### 注意：

1、每一个request对应一个end，调用end之后请求才算结束，write根据实际需求使用。

2、支持重定向。

## 三、事件

参考标准接口对事件监听进行了修改：封装一个类res。data、end事件由res触发。响应头封装在res.headers中，状态码保存在res.statusCode中，具体用法参考例子。

#### 1、error

发生错误时触发

```c
req.on('error', function(err))
 
//err
typedef enum {
	HTTP_CONNECT_OK,			//连接成功
	HTTP_PARSE_URL_FAIL,		//解析URL失败
	HTTP_CREATE_SOCKET_FAIL,	//创建socket失败
	HTTP_MALLOC_FAIL,			//内存分配失败
	HTTP_SEND_MSG_FAIL,			//发送消息失败
	HTTP_GET_HEADER_FAIL,		//获取响应头失败
	HTTP_GET_WRONG_STATUE_CODE,	//响应码错误
	HTTP_RECV_DATA_FAIL			//接收数据失败
	HTTP_CONNECT_TIMES_MAX,      //连续重定向次数达上限
} t_err_type;
```

#### 2、data

接收到响应数据时触发

```js
var req = http.request(options, function event(res) {
    console.log("req statusCode: ", res.statusCode);
    console.log("req headers: ", JSON.stringify(res.headers));
    res.on('data', function(chunk));
})
```

#### 3、end

连接结束时触发

```js
var req = http.request(options, function event(res) {
    res.on('end', function;
})
```

## 四、例子
### options 不携带body

```js 
var body = {
    did:"54236410002acaed",
    word:"人"
}

var options = {
    url: "https://spendict.gurobot.cn/api/v1/dict",
    method: "POST",
    timeout: 3000,
    headers: {
        "Content-Type": "application/json",
    }
}
var opt = {
    // 重定向测试网址
    url: "http://sdbtest.gurobot.cn/api/device/book/bin/123",
    method: "GET",
    timeout: 3000,
    headers: {
        "Content-Type": "application/json",
    }
}

var req = http.request(options, function event(res) {
    console.log("req1 statusCode: ", res.statusCode);
    console.log("req1 headers: ", JSON.stringify(res.headers));

    res.on('data', function event(chunk) {
        console.log("req1 chunk: ",chunk.toString());
    });

    res.on('end', function event() {
        console.log("req1  数据接收完毕");
    })
})

var req2 = http.request(opt, function event(res) {
    console.log("req2 statusCode: ", res.statusCode);
    console.log("req2 headers: ", JSON.stringify(res.headers));

    res.on('data', function event(chunk) {
        console.log("req2 chunk: ",chunk.toString());
    });

    res.on('end', function event() {
        console.log("req2 数据接收完毕");
    })
})

req.on('error', function event(error_info) {
    console.log("error info: ", error_info)
})

req2.on('error', function event(error_info) {
    console.log("req2 error info: ", error_info)
})


function destroy() {
    req.destroy();
    console.log("req1 destroy!");
}
function destroy2() {
    req2.destroy();
    console.log("req2 destroy!");
}

var time = Math.floor(Math.random() * (400 - 300 + 1)) + 300;
var time2 = Math.floor(Math.random() * (200 - 100 + 1)) + 100;

//定时终止请求
setTimeout(destroy, 1 * time);
setTimeout(destroy2, 1 * time2);


req.write(JSON.stringify(body));

req.end(function test(){console.log('this is end!');});
req2.end(function test(){console.log('req2 end!');});


```
### options 携带body
```
var options = {
	url: "https://spendict.gurobot.cn/api/v1/dict",
	method: "POST",
	timeout: 2000,
	headers: {
		"Content-Type": "application/json",
	},
	body: {
		uuid: '542364100000d754',
		keyword: '复习模块对前面10个模块所学的内容进行综合和融合性复习',
		size: 1
	}
}
options.url = 'http://spenquestion.gurobot.cn/api/v1/question/image/search'

var test2 = function() {
	var start = Date.now();
	var req = http.request(options, function event(res) {
		console.log("req statusCode: ", res.statusCode);
		console.log("req headers: ", JSON.stringify(res.headers));
		console.log("req body: ", res.body.toString());
		console.warn('body header time_start: ', Date.now() - start);
	})
}

test2();
```
### 同步请求用例
```js
var options = {
    url: "https://spendict.gurobot.cn/api/v1/dict",
    method: "POST",
    timeout: 3000,
    headers: {
        "Content-Type": "application/json",
    },
    body: {
	    "did":"54236410002acaed",
	    "word":"人"
	}
}
var opt = {
    // 重定向测试网址
    url: "http://sdbtest.gurobot.cn/api/device/book/bin/123",
    method: "GET",
    timeout: 3000,
    headers: {
        "Content-Type": "application/json",
    }
}

var resp = http.requestSync(options);
console.log("statusCode:", resp.statusCode);
console.log("headers:", resp.headers);
console.log("body:", resp.body.toString());
```

# Agent

## 一、模块介绍
创建一个http代理连接池，复用同一个host的连接，提高http请求效率

## 二、API

### 1、new http.agent(option)
返回一个代理连接池实例，每个host需要独立的连接池实例

- option：配置参数
    - maxSockets：允许打开的最大套接字连接数，主机尝试打开的连接数超过 maxSockets，则额外的请求将进入待处理请求队列，并在现有连接终止时进入活动连接状态。注意：目前并发数量超过设置的maxSocket时，会返回资源不足的错误，暂不支持排队处理，且为了资源可控，maxSockets的值最大允许不可超过实际项目固件配置的值
    - maxFreeSockets: 空闲状态下保持打开的最大套接字数。仅当 keepAlive 设置为 true 时才相关，当一个连接空闲后，如果当前空闲连接数已经达到了 maxFreeSockets，这个空闲连接就会被关闭并销毁，而不是保留以供将来复用
    - keepAlive：布尔值，是否保持连接活跃，以便在多个请求间复用连接。默认值是false，如果没有设置为ture，即使使用了连接池，也会在每次请求结束关闭连接。
    - keepAliveMsecs：number，默认值：1000，单位ms，当 keepAlive 为 true 时，控制保持连接的时间（毫秒），即连接空闲后的存活时间，超时后连接会关闭，进行资源回收，避免浪费。当 keepAlive 选项为 false 或 undefined 时则忽略
    - scheduling：字符串，用于控制当并发连接数有限时，如何将请求分配给可用的套接字，默认值为"lifo"
        - fifo（先进先出）：当有多个空闲套接字可用时，优先选择那些最早进入空闲状态的套接字
        - lifo（后进先出）：优先选择最近使用过的空闲套接字
    - timeout: 暂不支持设置该值，后续版本支持
        - 连接超时: 如果在指定的时间内未能建立连接，http.Agent 会终止连接尝试，并触发一个错误事件；
        - 请求超时: 如果连接成功建立，但在指定的时间内未能完成请求，http.Agent 会中止请求，并触发一个错误事件
    - sockets: 对象数组，存储当前正在使用的套接字的列表（即正在处理的连接）, 暂不支持
    - freeSockets：对象数组，存储空闲的套接字列表（可以复用的连接），暂不支持

### 2、agent.destroy()
销毁agent实例，调用该接口后，空闲的套接字会被回收，但正在请求的连接会等待请求结束后回收，新的请求不响应

### 注意事项
考虑到资源问题，如果项目使用的是872平台，建议最大的并发数即maxSockets设置为1，串行执行http，可以在原有的基础上减少建立socket的时间

## 三、事件

### error

```c
typedef enum {
    AGENT_CONNECT_TIMEOUT               = -1,  //连接或请求超时
    AGENT_MANY_OPEN_CONNECTIONS_ERROR   = -2,  //打开的连接已达到最大的并发量，不响应新的请求
    UNKNOWN_NETWORK_ERROR               = -3   //网络异常
}

目前仅支持AGENT_MANY_OPEN_CONNECTIONS_ERROR
```

## 四、例子

```js
var http = require("http"); 

//创建一个agent实例
var agent = new http.Agent({
    maxSockets: 3,
    scheduling: 'lifo',
    maxFreeSockets: 2,
    keepAlive: true,
    keepAliveMsecs: 60000
}); 

//监听error事件
agent.on("error", function(err) {
    console.log("agent err: ", err);
})

//将agent设置在http.request的请求参数里
var options = {
    url: "http://spendict.gurobot.cn/api/v1/dict",
    method: "POST",
    timeout: 3000,
    headers: {
        "Content-Type": "application/json",
    },
    agent: agent
}

var body = {
    did:"54236410002acaed",
    word:"人"
}

function http_req() {
    var timestamp = new Date().getTime();   
    var req = http.request(options, function event(res) {
        console.log("req" + cnt + " statusCode: ", res.statusCode);
        console.log("req" + cnt + " headers: ", JSON.stringify(res.headers));
    
        res.on('data', function event(chunk) {
            console.log("req" + cnt + " chunk: ",chunk.toString());
        });
    
        res.on('end', function event() {
            var timestamp2 = new Date().getTime();
            console.log("req" + cnt + "  时间: ",(timestamp2-timestamp)/1000,' 秒');
            console.log("req" + cnt + " 数据接收完毕");
        })
    })
    
    req.on('error', function event(error_info) {
        console.log("req" + cnt + " error info: ", error_info)
    })
    
    req.write(JSON.stringify(body));
    
    req.end(function test(){console.log("req" + cnt + " this is end!");});
}  

//发起请求
http_req();

```