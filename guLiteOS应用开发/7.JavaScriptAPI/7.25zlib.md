### 一、模块介绍

创建一个zlib解压缩对象，实现对数据的解压缩（目前仅实现gzip数据解压，其余的功能后续补充）

### 二、API

#### 1、zlib.gunzip(buffer, [options], callback)

以异步的方式实现gzip数据的解压
* buffer：数据类型：Buffer或者string，被压缩的数据
* options：可选参数，指定解压缩的参数，解压通常不需要传入
  * windowBits：number， 默认15，控制内部的窗口大小
  * memLevel: number， 默认8，控制内存的使用级别。值为1表示使用最小的内存，值为9表示使用最大的内存
  * chunkSize: number， 默认16 * 1024，内部缓冲区的大小，用于控制解压缩流
  * flush: number，默认0， 控制在压缩流中何时进行数据刷新的参数
  * finishFlush: number， 默认4， 与flush选项一起使用，用于指定在完成时进行数据刷新的参数
* callback(err, data)：可选，回调函数, 错误码err: 0表示成功，-1表示失败， data: 以Buffer的格式返回解压后的数据

#### 2、zlib.gunzipSync(buffer, [options])

以同步的方式实现gzip数据的解压，传入的参数解释参考zlib.gunzip()

* 返回值：成功则以Buffer的格式返回解压后的数据，失败则返回null

### 三、例子

```js
var http = require('http');
var zlib = require('zlib');

var opt = {
    url: "http://localhost:3000/",
    method: "GET",
    timeout: 3000,
    headers: {
        "Content-Type": "application/json",
    }
}

var req2 = http.request(opt, function event(res) {
    console.error("req2 statusCode: ", res.statusCode);
    console.error("req2 headers: ", JSON.stringify(res.headers));
    var isGzipped = res.headers['Content-Encoding'] === 'gzip';
    var date = new Buffer(0);
    res.on('data', function event(chunk) {
        console.error("req2 chunk: ", chunk);
        date = Buffer.concat([date, chunk]);
    });

    res.on('end', function event() {
        if (isGzipped) {
            console.log("date: ", date);
            zlib.gunzip(date, function(err, buf) {
                if (!err) {
                    console.log("buf: ", buf.toString());
                }
            })
        }
        console.log("req2 数据接收完毕");
    })
})

req2.on('error', function event(error_info) {
    console.log("req2 error info: ", error_info)
})
req2.end();

```