# 一、对接的api介绍
* 特殊平台需要自行填充，linux、 freertos、 macos平台可使用默认配置，不需要修改

```
/**
 * @brief 创建二值信号量
 *
 * @param init_count 二值信号量的初始值，取值0或者1
 * @return 二值信号量的句柄
 */
void* os_wrapper_signal_mutex_create(int init_count);
```
```
/**
 * @brief 创建信号量
 *
 * @param init_count 二值信号量的初始值，取值0或者1
 * @return 二值信号量的句柄
 */
void* os_wrapper_signal_create(int init_count, unsigned int maxCount);
```
```
/**
 * @brief 二值信号量等待信号
 *
 * @param sem 二值信号量的句柄
 * @paran time_ms 等待时间，如果要永远等待下去，需要传入os_wrapper_get_forever_time的返回值
 * @return int
 */
int os_wrapper_signal_wait(void* sem, long time_ms);
```
```
/**
 * @brief 二值信号量释放信号
 *
 * @param mutex 二值信号量的句柄
 * @return int
 */
int os_wrapper_signal_post(void* sem);
```
```
/**
 * @brief 删除二值信号量
 *
 * @param mutex 二值信号量的句柄
 * @return int
 */
int os_wrapper_signal_delete(void** sem);
```
```

////////////////////////////////////////////////////////////////////////////
/*****************************mutex api************************************/
////////////////////////////////////////////////////////////////////////////
/**
 * @brief 创建互斥量，一般用于保护公共变量，处理线程安全问题
 *
 * @param
 * @return 互斥量的句柄
 */
void* os_wrapper_mutex_create(void);
```
```
/**
 * @brief 互斥量加锁
 *
 * @param mutex 目标互斥量的句柄
 * @paran time_ms 等待时间，如果要永远等待下去，需要传入os_wrapper_get_forever_time的返回值
 * @return 为0代表加锁成功，其他代表失败或者超时
 */
int os_wrapper_mutex_lock(void* mutex, long time_ms);
```
```
/**
 * @brief 互斥量解锁
 *
 * @param mutex 目标互斥量
 * @return int
 */
int os_wrapper_mutex_unlock(void* mutex);
```
```
/**
 * @brief 删除互斥量
 *
 * @param mutex 目标互斥量
 * @return int
 */
int os_wrapper_mutex_delete(void** mutex);
```
```

////////////////////////////////////////////////////////////////////////////
/******************************queue api***********************************/
////////////////////////////////////////////////////////////////////////////

/**
 * @brief 创建消息队列
 *
 * @param queue_len, 消息队列长度
 * @param size, 消息的大小
 * @return 互斥量的句柄
 */	
void* _os_wrapper_queue_create(const char *name, unsigned int queue_len, unsigned int size);
#define os_wrapper_queue_create(queue_len, size) _os_wrapper_queue_create(__func__, queue_len, size);
```
```
/**
 * @brief 消息队列发送消息
 *
 * @param queue 目标消息队列的句柄
 * @param item 要发送的消息体
 * @paran time_ms 等待时间，如果要永远等待下去，需要传入os_wrapper_get_forever_time的返回值
 * @return int
 */
int os_wrapper_queue_send(void* queue, const void *item, long time_ms);
```
```
/**
 * @brief 消息队列接收消息
 *
 * @param queue 目标消息队列的句柄
 * @param item 要接收的消息体指针
 * @paran time_ms 等待时间，如果要永远等待下去，需要传入os_wrapper_get_forever_time的返回值
 * @return int
 */

int os_wrapper_queue_recv(void* queue, void *item, long time_ms);
```
```
/**
 * @brief 删除消息队列
 *
 * @param queue 目标消息队列
 * @return int
 */
int os_wrapper_queue_delete(void** queue);
```
```
/**
 * @brief 获取消息队列个数
 *
 * @param queue 目标消息队列
 * @return int
 */
int os_wrapper_queue_check(void* queue);
```
```

////////////////////////////////////////////////////////////////////////////
/*****************************thread api***********************************/
////////////////////////////////////////////////////////////////////////////

/**
 * @brief 此函数一般用于freeRTOS, 在task末尾调用vTaskDelete(NULL),其他OS一般用不到
 *
 * @param thread_handle 线程句柄
 * @return void
 */
int os_wrapper_thread_delete(void** thread_handle);
```
```
/**
 * @brief 启动线程
 * @param thread 线程的句柄，NULL代表启动线程失败
 * @param thread_func 线程函数，void ()(void*)
 * @param param 线程参数
 * @param name 线程名称
 * @param prior 线程优先级，数值越大优先级越高
 * @param stack_depth 线程栈深度，注意，单位为字（4bytes）
 * @return 0:success, -1:fail
 */
int os_wrapper_thread_create(void **thread, void* thread_func, void* param, const char* name, int prior, int stack_depth);
```
```
/**
 * @brief 判断线程是否还存在
 *
 * @param thread_handle 线程句柄
 * @return void
 */
int os_wrapper_thread_is_valid(void* thread_handle);
```
```
/**
 * @brief 修改任务优先级
 *
 * @param thread 线程句柄
 * @param priority 线程优先级
 * @return void
 */
int os_wrapper_thread_set_priority(void* thread, unsigned char priority);
```
```
/**
 * @brief 获取当前任务句柄
 *
 * @return long int 句柄整形
 */
long os_wrapper_thread_get_tid(void* thread);
```
```

////////////////////////////////////////////////////////////////////////////
/*****************************time api************************************/
////////////////////////////////////////////////////////////////////////////

/**
 * @brief 获取从开机到当前时刻的持续时间
 *
 * @param 
 * @return 从开机到当前时刻的持续时间，单位为毫秒
 */
long os_wrapper_get_time_ms(void);
```
```
/**
 * @brief 睡眠
 *
 * @param time_ms 毫秒数
 * @return void
 */
void os_wrapper_msleep(long time_ms);
```
```
/**
 * @brief 在信号量等待信号，或者互斥量加锁的时候，如果要持续等待到获得信号或者加锁成功为止，需要调用此函数，并将结果作为参数传入对应函数中；
 * 例如：os_wrapper_wait_signal(mutex, os_wrapper_get_forever_time());
 *
 * @param 
 * @return 二值信号量的句柄
 */
long os_wrapper_get_forever_time(void);
```
```
/**
 * @brief 获取时间戳
 *
 * @param timestamp 时间戳字符串
 * @return void
 */
void os_wrapper_get_timestamp(char *timestamp);
```
```

////////////////////////////////////////////////////////////////////////////
/*****************************timer api************************************/
////////////////////////////////////////////////////////////////////////////
/**
 * @brief 创建定时器
 *
 * @param handle 出参，timer的句柄
 * @param repeat true代表定时器将重复触发，false代表只触发一次
 * @param func 定时器触发时执行的函数
 * @param arg
 * @param period_ms 定时间隔，单位为毫秒
 * @return void*
 */
void* os_wrapper_timer_create(bool repeat, void* func, void *arg, int period_ms);
```
```
/**
 * @brief 删除定时器
 *
 * @param handle timer的句柄
 * @return int 成功与否
 */
int os_wrapper_timer_delete(void** timer);
```
```
/**
 * @brief 启动定时器
 *
 * @param handle timer的句柄
 * @return void
 */

int os_wrapper_timer_start(void* timer);
```
```
/**
 * @brief 停止定时器
 *
 * @param handle timer的句柄
 * @return int
 */
int os_wrapper_timer_stop(void* timer);
```
```
/**
 * @brief 停止定时器
 *
 * @param handle timer的句柄
 * @return int
 */
int os_wrapper_timer_is_active(void* timer);
```
```
/**
 * @brief 修改定时器周期时间
 *
 * @param handle timer的句柄
 * @param period_ms timer的新周期时间
 * @return int
 */
int os_wrapper_timer_change_period(void* timer, int period_ms);

```
```
/**
 * @brief 获取errno
 *
 * @param void
 * @return int
 */
int os_wrapper_get_errno(void);
```
```
/**
 * @brief set errno
 *
 * @param int 
 * @return void
 */
void os_wrapper_set_errno(int err);
```
